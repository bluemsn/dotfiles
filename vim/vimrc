" Basic stuff {{{1

set nocompatible      " Forget about being compatible with good ol' vi
set hidden            " Keep changed buffers without requiring saves
set ttyfast           " Indicates a faster terminal connection

" Use the system's clipboard
" http://twitter.com/mbadran/status/111011179907915776
set clipboard=unnamed

" Runtime stuff {{{1

" The % key will switch between opening and closing brackets. By sourcing
" matchit.vim — a standard file in Vim installations for years — the key can
" also switch among e.g. if/elsif/else/end, between opening and closing XML
" tags, and more.
runtime +=macros/matchit.vim

" Vundle & other extensions (syntaxes, filetype's etc.) {{{1

" Set the filetype stuff to off, required for Vundle
filetype off
filetype plugin indent off

set rtp+=~/.vim/bundle/vundle/ " Add Vundle to the list of things to load
call vundle#rc() " Call a Vundle function... Probably loads Vundle itself

" Let Vundle handle itself as a bundle, REQUIRED!
Bundle 'gmarik/vundle'

" All of my Vundle bundles {{{2

" Active bundles {{{3

Bundle 'godlygeek/csapprox'
Bundle 'jeffkreeftmeijer/vim-numbertoggle'
Bundle 'Lokaltog/vim-easymotion'
Bundle 'Raimondi/delimitMate'
Bundle 'sjl/vitality.vim'
Bundle 'taq/vim-git-branch-info'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-surround'
Bundle 'vim-scripts/SearchComplete'

" Language specific bundles {{{3

Bundle 'nelstrom/vim-markdown-folding'
Bundle 'spf13/PIV'

" Syntax files {{{3

Bundle 'olivierverdier/python-syntax.vim'
Bundle 'tpope/vim-git'
Bundle 'tpope/vim-markdown'

" Color schemes {{{3

Bundle 'altercation/vim-colors-solarized'
Bundle 'chriskempson/base16-vim'
Bundle 'nanotech/jellybeans.vim'

" Deactivated bundles {{{3

"Bundle 'mattn/zencoding-vim'
"Bundle 'nathanaelkane/vim-indent-guides'
"Bundle 'PotHix/Vimpress'
"Bundle 'scrooloose/nerdcommenter'
"Bundle 'scrooloose/nerdtree'
"Bundle 'vim-scripts/YankRing.vim'

" Bundles to check out {{{3

"Bundle 'godlygeek/tabular'
"Bundle 'kien/ctrlp.vim'
"Bundle 'Lokaltog/powerline'
"Bundle 'mileszs/ack.vim'
"Bundle 'SirVer/ultisnips'
"Bundle 'sjl/clam.vim'
"Bundle 'sjl/friendly-find'
"Bundle 'sjl/gundo.vim'
"Bundle 'tpope/vim-commentary'
"Bundle 'tpope/vim-fugitive'
"Bundle 'tpope/vim-pastie'
"Bundle 'tsaleh/vim-align'
"Bundle 'vim-scripts/Conque-Shell'

" }}}3

" }}}2

" Set the filetype stuff to on
filetype on
filetype plugin indent on

" Bundle settings {{{2

" Vim Indent Guides {{{3
"let g:indent_guides_guide_size=1  " Set width of marker to one wide
"let g:indent_guides_enable_on_vim_startup=1 " Load bundle at startup
"au VimEnter * :IndentGuidesEnable " Always load bundle
" Git Branch Info {{{3
let g:git_branch_status_text=' ' " Add a space before info
let g:git_branch_status_head_current=1 " Only show current branch
let g:git_branch_status_nogit='' " Message when there's no Git repo
let g:git_branch_status_around='()' " Enclose the branch in between these
let g:git_branch_file_based=1 " Check the file for info, instead of directory
" NERDtree {{{3
let NERDTreeMinimalUI=1
let NERDTreeDirArrows=1
" EasyMotion {{{3
let g:EasyMotion_Leader_key='<leader><leader>'
" }}}3

" }}}2

" Search & matching {{{1

set wrapscan    " Set the search scan to wrap around to the top of the file
set ignorecase  " Set search scan to ignore case when search is all lowercase
set smartcase   " But recognize uppercase if it is specified
set visualbell  " Set to use visual bell --  the beeping sucks!
set errorbells  " Enable use of (visual) error bells
set incsearch   " Show results of search scan as it finds them
set showmatch   " Always show matching bracket, quote etc.
set matchtime=5 " Tenths of a second to show the matching bracket, quote etc.
set hlsearch    " Enable the highlighting of the search
set showcmd     " Show the current command in the lower right corner
set magic       " Allow use of regular expressions in the search scans

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

if has('win32')
    set grepprg=internal " Windows findstr.exe just isn't good enough
endif

" Formatting {{{1

set tabstop=4     " Number of spaces that defines a "tab"
set shiftwidth=4  " Number of spaces to use for each indent level
set softtabstop=4 " Same as 'tabstop', while doing editing operations
set shiftround    " Round indent to pultiple of 'shiftwidth'
set backspace=indent,eol,start " Backspace over everything in insert mode
set smartindent   " Do smart indenting when starting a new line
set autoindent    " Copy indent from current line, over to the new line
set fo=vt         " Set the format options ('formatoptions')

" Commands options {{{1

set cpoptions=ces$  " Make the 'cw' and like commands put a $ at the end of the
                    " word instead of just deleting and replacing the text
set notimeout       " Don't time out on mappings
set ttimeout        " But do timeout on key codes, like cursor keys
set ttimeoutlen=500 " Set the timeout lenght in milliseconds

" Command line options {{{1

set ch=2       " Make the command input line two lines high
set shellslash " Set to use forward slash, in case you're in Windows

" History {{{1

set history=100 " Keep only 100 entries in the command history
set nobackup    " Disable backup files
set noswapfile  " Don't use a swap file in current buffer
set nowb        " Don't write backup before saving, even if you delete it later

" Folds {{{1

set foldenable        " Make sure folding is enabled
set foldmethod=marker " Use manual markers for folds
set foldlevelstart=0  " Always close folds when switching buffers

" These commands open can open folds
set foldopen=block,insert,jump,mark,percent,quickfix,search,tag,undo

" Keymappings stuff {{{1

" Set Leader key to ',', instead of '/'
let mapleader=','
let g:mapleader=','

" Set my local Leader key to '\'
let maplocalLeader = '\\'

" Map CTRL-E to do what ',' used to do
nnoremap <c-e> ,
vnoremap <c-e> ,

" Reverse their effects
nnoremap ' `
nnoremap ` '

" Let's make it easy to edit this file, use ',eev' to open this file, and ',ev'
" for opening it in a split window
nnoremap <silent> <leader>eev :e $MYVIMRC<CR>
nnoremap <silent> <leader>ev :sp $MYVIMRC<CR>

" And to source this file as well, use ',sv' to source this file
nnoremap <silent> <leader>sv :so $MYVIMRC<CR>

" Completely disable the use of the arrow keys in command and visual modes
noremap <up> <nop>
noremap <down> <nop>
noremap <left> <nop>
noremap <right> <nop>

" Fix moving line by line in the paragraph, when soft wrap is on
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

" Smart way to move between windows, uses 'Ctrl+jkhl' instead of 'Ctrl+w+jkhl'
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" Disable pressing 'F1' for help, and set it equal to Escape
noremap <F1> <esc>

" Makes it easy to clear out a search, by typing ',<space>'
nnoremap <leader><space> :noh<CR>

" Allow change of theme from light to dark and vice-versa, with a hotkey
call togglebg#map('<F5>')

" Change current WORD in normal mode to UPPERCASE letters using ',U'
nnoremap <leader>U viwU<esc>

" And the same to lowercase using ',u'
nnoremap <leader>u viwu<esc>

" Same as *, but doesn't move the cursor, only highlights
" http://twitter.com/dmedvinsky/status/109304047206547456
nnoremap <silent> <leader>hh :setl hls<CR>:let @/="\\<<C-r><C-w>\\>"<CR>

" Preserve indentation while pasting text from the OS X clipboard
noremap <leader>p :set paste<CR>:put  *<CR>:set nopaste<cCR>

" Use ',z' to focus current fold, closing every other fold in the process
" http://twitter.com/dotvimrc/status/129979569045381120
nnoremap <leader>z zMzvzz

" Use capital H/L to first/last non-space character
" http://twitter.com/dotvimrc/status/132489424494792704
noremap H ^
noremap L g_

" Select (charwise) the contents of the current line, excluding indentation
" http://twitter.com/dotvimrc/status/155748943001694208
nnoremap vv ^vg_

" CTRL-A selects all
" https://github.com/wnodom/wnodom-vim-environment/blob/master/.vimrc#L325
noremap <C-A> gggH<C-O>G
inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
cnoremap <C-A> <C-C>gggH<C-O>G
onoremap <C-A> <C-C>gggH<C-O>G
snoremap <C-A> <C-C>gggH<C-O>G
xnoremap <C-A> <C-C>ggVG

" Abbreviations {{{1

" Set abbreviations for all my emails
iabbrev el@@ eduanlavaque@gmail.com
iabbrev es@@ eduan@snapsimpletech.com
iabbrev ew@@ eduan@websharks-inc.com

" UI related {{{1

"set list                    " Show hidden characters
"set listchars=tab:▸\ ,eol:¬ " Set chars to use for 'list'
set title                   " Change Terminal's title
set numberwidth=4           " Line numbers always be 4 chars wide
set colorcolumn=79          " Put a marker in array of column numbers
set shortmess=atI           " :h shortmess

" NOTICE!
" Line numbers and relative line numbers are controlled by this bundle:
" https://github.com/jeffkreeftmeijer/vim-numbertoggle

" Status line {{{2

set laststatus=2 " Always use a statusline 
set ruler        " Put a ruler, when my custom statusline doesn't load

if has('multi_statusline') "{{{3
	" If you don't know what this means:
	" https://gist.github.com/3158492

	" The amount of lines the statusline is allowed to have
	set statuslineheight=2

	let &stl=''        " Clear statusline for when vimrc is loaded
	let &stl.='[%02n]' " Buffer number of current buffer
	let &stl.=' '      " Separator
	let &stl.='{'      " Opening curly bracket, for item group
	let &stl.='%('     " Start of item group
	let &stl.='%M'     " Show modified status of buffer: -, +, 
	let &stl.='%R'     " Show if file is read-only: RO
	let &stl.='%W'     " Show if buffer is a preview item?: PRV
	let &stl.='%H'     " Show if buffer is a help file: HLP
	let &stl.='%)'     " End of item group
	let &stl.='}'      " Closing curly bracket, for item group
	let &stl.=' '      " Separator
	let &stl.='[%{&ft!=""?&ft.", ":""}'    " Buffer's file type
	let &stl.='%{&fenc!=""?&fenc:&enc}'    " Buffer's encoding
	let &stl.='%{empty(&ff)?"":", ".&ff}]' " Buffer's file type
	let &stl.='%{GitBranchInfoString()}'   " Buffer's Git branch
	let &stl.='%='     " Right side of first statusline
	let &stl.=' '      " Separator
	let &stl.='%<'     " Truncate from here on
	let &stl.='%F'     " Full path to file
	let &stl.='%@'     " Go to next line of statusline

	let &stl.='[%b'    " Value of character under cursor
	let &stl.=':'      " Separator between '%b' and '%B'
	let &stl.='0x%B]'  " As above, in hexadecimal
	let &stl.=' '      " Separator
	let &stl.='[L%l'   " Cursor's current line
	let &stl.='/'      " Separator for current line and total of lines
	let &stl.='%L'     " Total of lines
	let &stl.=':'      " Separator between line and column info
	let &stl.='C%c'    " Current column
	let &stl.='-'      " Separator between column and virtual column
	let &stl.='%v]'    " Current virtual column
	let &stl.=' '      " Separator
	let &stl.='(%p%%)' " Percentage through file in lines, as in <c-g>
	let &stl.='%='     " Right side of second statusline
	let &stl.=' '      " Separator
	let &stl.='%f'

"}}}3
else "(normal Vim installation) {{{3
	let &stl=''        " Clear statusline for when vimrc is loaded
	let &stl.='[%02n]' " Buffer number of current buffer
	let &stl.=' '      " Separator
	let &stl.='{'      " Opening curly bracket, for item group
	let &stl.='%('     " Start of item group
	let &stl.='%M'     " Show modified status of buffer: -, +, 
	let &stl.='%R'     " Show if file is read-only: RO
	let &stl.='%W'     " Show if buffer is a preview item?: PRV
	let &stl.='%H'     " Show if buffer is a help file: HLP
	let &stl.='%)'     " End of item group
	let &stl.='}'      " Closing curly bracket, for item group
	let &stl.=' '      " Separator
	let &stl.='%<'     " Truncate from here on
	let &stl.='%F'     " Full path to file
	let &stl.=' '      " Separator
	let &stl.='[%{&ft!=""?&ft.", ":""}'    " Buffer's file type
	let &stl.='%{&fenc!=""?&fenc:&enc}'    " Buffer's encoding
	let &stl.='%{empty(&ff)?"":", ".&ff}]' " Buffer's file type
	let &stl.='%{GitBranchInfoString()}'   " Buffer's Git branch

	let &stl.='%='     " Right line of statusline
	let &stl.=' '      " So there's a space between both sides
	let &stl.='[%b'    " Value of character under cursor
	let &stl.=':'      " Separator between '%b' and '%B'
	let &stl.='0x%B]'  " As above, in hexadecimal
	let &stl.=' '      " Separator
	let &stl.='[L%l'   " Cursor's current line
	let &stl.='/'      " Separator for current line and total of lines
	let &stl.='%L'     " Total of lines
	let &stl.=':'      " Separator between line and column info
	let &stl.='C%c'    " Current column
	let &stl.='-'      " Separator between column and virtual column
	let &stl.='%v]'    " Current virtual column
	let &stl.=' '      " Separator
	let &stl.='(%p%%)' " Percentage through file in lines, as in <c-g>
endif "}}}3

" Cursor & mouse {{{2

set scrolloff=4     " Keep the cursor 4 lines above/below window edge
set sidescrolloff=4 " Same as above, but for side scrolling
set sidescroll=1    " Minimal columns to scroll horizontally
set virtualedit=all " Allow the cursor to go to invalid places
set mousehide       " Hide the mouse pointer while typing
set mouse=          " Disable use of mouse

augroup cline
	autocmd!

	" Only show 'cursorline' in the current window and in normal mode
	au WinLeave,InsertEnter * set nocursorline
	au WinEnter,InsertLeave * set cursorline

	" Only show 'cursorcolumn' in current window and in normal mode
	au WinLeave,InsertEnter * set nocursorcolumn
	au WinEnter,InsertLeave * set cursorcolumn
augroup END

" Windows/Split-windows {{{2

set fillchars=""             " Don't put window separators between splits
set autowrite                " When switching buffers save file automatically
set autoread                 " Auto read files when edited outside Vim
set tabpagemax=1             " Max tabs to open with the '-p' option
set showtabline=0            " Don't show the Vim tab line
set switchbuf=useopen,usetab " Switch to tab/window if buffer is already open
set guioptions=acirbhv       " Set the GUI options the way I like them
au VimResized * :wincmd =    " Resize split windows when the window is resized
au FocusLost * :wa           " Save all buffers when it loses focus

" Syntax highlighting {{{2

set synmaxcol=2048 " Put a max of 2048 chars to highlight in a single line
if &t_Co > 2 || has('gui_running')
	" Switch syntax highlighting on, when the Terminal has colors
	" Or when the GUI is being used
	syntax on
endif

" Solarized settings {{{3

" Make Solarized use 256 colors
"let g:solarized_termcolors=256

" Compatibility for Terminal
"let g:solarized_termtrans=1

" Non-text items visibility, normal low or high
let g:solarized_visibility='normal'

" Show trailing white spaces
let g:solarized_hitrail=1

" Disable the Solarized menu
let g:solarized_menu=0

" }}}3

set background=light " Use the light/dark version of the color scheme
colorscheme solarized " Set the color scheme to use

if has('gui_running') "{{{2
	" Fix spell check highlighting
	highlight SpellBad term=underline gui=undercurl guisp=Red

	" Set up the GUI cursor to look nice, for each mode
	set guicursor=n-v-c:block-Cursor-blinkon0
	set guicursor+=ve:ver35-Cursor
	set guicursor+=o:hor50-Cursor
	set guicursor+=i-ci:ver25-Cursor
	set guicursor+=r-cr:hor20-Cursor
	set guicursor+=sm:block-Cursor-blinkwait175-blinkoff150-blinkon175

	" Set the window position to these coordinates
	winpos 0 0

	" Set the font
	set guifont=Monaco:h11

	if ! $diff " Check if in diff mode
		" If not, do a normal sized window
		set columns=120 lines=40 " Set the width and height of window
	else
		" If yes, then double that for diff mode
		set columns=240 lines=40 " Same here, duh!
	endif

	if has('gui_macvim')
		set fuoptions=maxvert,maxhorz " Full screen means FULL screen
	else
		" Other GUIs like, Gvim go here
	endif
else
	" Terminal only stuff!
endif

"}}}2

" Diff {{{1

set diffopt+=iwhite " Add ignorance of whitespace to diff

" Auto-completion {{{1

set wildmenu              " Use wildmenu auto completion
set wildmode=list:longest " Set options for auto completion
set complete=.,w,b,t      " Default, except that I remove the 'u' option 
set showfulltag           " Show whole tag, not just function name, when
                          " autocompleting by tag

" Macros {{{1

set lazyredraw " Don't update the display while executing macros

" File {{{1

set key=             " Disable encryption file and buffer encryption 
set nobomb           " Don't use BOM's (Byte Order Marks)
set ffs=unix,dos,mac " Set filetype to Unix, Windows and then Mac (Power PC)

" Set the buffer encoding to be UTF-8
set encoding=utf-8
set termencoding=utf-8
set fileencodings=utf-8,iso-8859-15
setglobal fileencoding=utf-8

" File type specific stuff {{{1

" Set to use manual folds in Vim files
augroup filetype_vim
	autocmd!
	autocmd FileType vim setlocal foldmethod=marker
augroup END

" Python specific stuff
augroup filetype_python
	autocmd!
	autocmd FileType python setlocal expandtab
	autocmd FileType python setlocal complete+=k~/.vim/syntax/python.vim isk+=.,(
	autocmd FileType python setlocal smartindent set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class
augroup END

augroup filetype_text
	autocmd!
	autocmd FileType text setlocal formatprg=par\ w79r
augroup END

" Functions {{{1

" Add a "number" text object {{{2

" Add's a number as a text object, so from '#123456' the number is everything
" except the '#', at least that's how I understand it.
"
" I got this excellent piece of VimL from here:
" http://sprunge.us/QTPL?vim

onoremap N :<c-u>call <SID>NumberTextObject(0)<CR>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<CR>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<CR>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<CR>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<CR>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<CR>

function! s:NumberTextObject(whole)
	normal! v

	while getline('.')[col('.')] =~# '\v[0-9]'
		normal! l
	endwhile

	if a:whole
		normal! o

		while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9]'
			normal! h
		endwhile
	endif
endfunction

" Change Syntax {{{2

" Quickly change the file's syntax, put in a function.
"
" I invented this one, so no need to link anywhere.

" Define the function that does everything
function! ChangeSyntax(name)
	set syntax=a:name
endfunction

" Make it a callable function through the Vim command line
command! -nargs=* -complete=syntax ChangeSyntax call ChangeSyntax('arg')

" Set to use the ',cs' mapping
:nnoremap <leader>cs :ChangeSyntax<Space>

" Show syntax rule(s) for whatever is under the cursor {{{2

" This functly allows you to figure out the name of the text object you're on
" top of.
"
" I got this one from here:
" http://vimcasts.org/episodes/creating-colorschemes-for-vim/

function! <SID>SynStack()
	if !exists("*synstack")
		return
	endif
	echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

nnoremap <C-S-P> :call <SID>SynStack()<CR>

" Shell {{{2

" This function allows you to run shell commands from within Vim, and open it
" in a vertical split
"
" I got this from here:
" https://bitbucket.org/sjl/dotfiles/src/b5e60ade957d/vim/.vimrc?at=default#cl-677

 function! s:ExecuteInShell(command) " {{{
    let command = join(map(split(a:command), 'expand(v:val)'))
    let winnr = bufwinnr('^' . command . '$')
    silent! execute  winnr < 0 ? 'botright vnew ' . fnameEscape(command) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap nonumber
    echo 'Execute ' . command . '...'
    silent! execute 'silent %!'. command
    silent! redraw
    silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>:AnsiEsc<CR>'
    silent! execute 'nnoremap <silent> <buffer> q :q<CR>'
    silent! execute 'AnsiEsc'
    echo 'Shell command ' . command . ' executed.'
endfunction " }}}
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)
nnoremap <leader>! :Shell 

" Motion for next object {{{2

" Motion for "next/last object". For example, "din(" would go to the next "()" pair
" and delete its contents.
"
" I got this one from here:
" https://gist.github.com/1171642

onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<CR>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<CR>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<CR>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<CR>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<CR>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<CR>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<CR>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<CR>

function! s:NextTextObject(motion, dir)
	let c = nr2char(getchar())

	if c ==# "b"
		let c = "("
	elseif c ==# "B"
		let c = "{"
	elseif c ==# "d"
		let c = "["
	endif

	exe "normal! ".a:dir.c."v".a:motion.c
endfunction

" }}}2

" Tips {{{1

" To show all your commands mapped to your Leader key
":map <leader>

" To show all help topics containing 'help'
":h word<CTRL-d>

